from __future__ import absolute_import, print_function

import sys
import traceback

from Qt import QtCompat

from . import config, plugins
from .contexts import ErrorReport


class PreditorExceptHook(object):
    """Replacement for `sys.excepthook` that adds error reporting features.

    This calls each callable in the `preditor.config.excepthooks` list any time
    `sys.excepthook` is called due to an raised exception.

    If `config.excepthook` is empty when installing this class, it will
    automatically add the `call_base_excepthook` and `ask_to_show_logger` methods.
    This enables showing the excepthook in parent streams and prompting the user
    to show PrEditor when an error happens. You can disable this by adding `None`
    to the list before this class is initialized.
    """

    def __init__(self, base_excepthook=None):
        self.base_excepthook = base_excepthook or sys.__excepthook__

        # Add the default excepthooks
        if not config.excepthooks and config.excepthooks != [None]:
            config.excepthooks.append(self.call_base_excepthook)
            config.excepthooks.append(self.ask_to_show_logger)

    def __call__(self, *exc_info):
        """Run when an exception is raised and calls all `config.excepthooks`."""
        for plugin in config.excepthooks:
            if plugin is None:
                continue
            plugin(*exc_info)

        # Clear any ErrorReports that were generated by this exception handling
        ErrorReport.clearReports()

    def call_base_excepthook(self, *exc_info):
        """Process `base_excepthook` supplied during object instantiation.

        This is useful for showing the exception in the original excepthook that
        PrEditor replaced when this class was installed.

        A newline is printed pre-traceback to ensure the first line of output
        is not printed in-line with the prompt. This also provides visual
        separation between tracebacks, when received consecutively.
        """
        print("")
        try:
            self.base_excepthook(*exc_info)
        except (TypeError, NameError):
            sys.__excepthook__(*exc_info)

    def ask_to_show_logger(self, *exc_info):
        """Show a dialog asking the user how to handle the error."""
        if config.error_dialog_class is True:
            # Default to the base ErrorDialog class
            from .gui.errordialog import ErrorDialog

            config.error_dialog_class = ErrorDialog
        elif isinstance(config.error_dialog_class, str):
            # If passed an EntryPoint string load the EntryPoint
            config.error_dialog_class = plugins.from_string(config.error_dialog_class)

        # Handle cases where we shouldn't ask to show the logger.
        if config.error_dialog_class is None:
            return
        elif not config.error_dialog_class.show_prompt(*exc_info):
            return

        from .gui.console import ConsolePrEdit
        from .gui.loggerwindow import LoggerWindow

        instance = LoggerWindow.instance(create=False)

        if instance:
            # logger reference deleted, fallback and print to console
            if not QtCompat.isValid(instance):
                print("[LoggerWindow] LoggerWindow object has been deleted.")
                # TODO: This seems incorrect, what should it be printing?
                print(traceback)
                return

            # logger is visible and check if it was minimized on windows
            if instance.isVisible() and not instance.isMinimized():
                if instance.uiAutoPromptACT.isChecked():
                    instance.console().startInputLine()
                return

        # error already prompted by exception currently being handled
        if ConsolePrEdit._errorPrompted:
            return

        # Preemptively marking error as "prompted" (handled) to avoid errors
        # from being raised multiple times due to C++ and/or threading error
        # processing.
        try:
            ConsolePrEdit._errorPrompted = True
            errorDialog = config.error_dialog_class(config.root_window())
            errorDialog.setText(exc_info)
            errorDialog.exec_()

        # interrupted until dialog closed
        finally:
            ConsolePrEdit._errorPrompted = False

    @classmethod
    def install(cls, force=False):
        """
        Install PrEditor excepthook override, returning previously implemented
        excepthook function.

        Arguments:
            force (bool): force re-installation of excepthook override when
                already previously implemented.

        Returns:
            func: pre-override excepthook function
        """
        ErrorReport.enabled = True
        prev_excepthook = sys.excepthook

        if not isinstance(prev_excepthook, cls) or force:
            sys.excepthook = cls(prev_excepthook)

        return prev_excepthook
